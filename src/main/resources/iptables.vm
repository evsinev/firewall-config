# Generated by firewall-config
*filter
:INPUT   DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT  DROP [0:0]

# loopback interface
-A INPUT  -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

# simple atacks

-A INPUT -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Drop Sync"
-A INPUT -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -j DROP
-A INPUT -f -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Fragments Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,PSH,URG -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,PSH,ACK,URG -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "NULL Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
-A INPUT -p tcp -m tcp --tcp-flags SYN,RST SYN,RST -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN FIN,SYN -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "XMAS Packets"
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,ACK FIN -m limit --limit 5/min --limit-burst 7 -j LOG --log-prefix "Fin Packets Scan"
-A INPUT -p tcp -m tcp --tcp-flags FIN,ACK FIN -j DROP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,ACK,URG -j DROP


#
# INPUT packets
#
#if ( $blocked-ip-addresses.size() > 0 )
#
# BLOCKED HOSTS
#
#foreach( $block in $blocked-ip-addresses )
# $block.reason
-A INPUT -s $block.ip -j $block.type
#end

#end
#foreach( $p in $input-packets )
# $p.source_address_name -> $p.app_protocol
#if ($p.destination_port > 0 )
-A INPUT  -i $p.input_interface -p $p.protocol -m $p.protocol -s $p.source_address --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -o $p.input_interface -p $p.protocol -m $p.protocol -d $p.source_address --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A INPUT  -i $p.input_interface -p $p.protocol -s $p.source_address -j ACCEPT
#end

#end
#if ( $input-mss.size() > 0 )
#
# MSS
#
#foreach( $p in $input-mss )
# -> $p.source_address_name [$p.destination_service]
-A INPUT -s $p.source_address -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss $p.mss
#end
#end

# Enable ICMP input for all interfaces
-A INPUT --protocol icmp --icmp-type echo-reply               -j ACCEPT
-A INPUT --protocol icmp --icmp-type destination-unreachable  -j ACCEPT
-A INPUT --protocol icmp --icmp-type echo-request             -j ACCEPT
-A INPUT --protocol icmp --icmp-type time-exceeded            -j ACCEPT

#if ( $custom-input-rules.size() > 0 )
# Custom INPUT Rules
#foreach( $rule in $custom-input-rules )
# $rule.description / $rule.justification
$rule.rule
#end
#end

#
# OUTPUT packets
#
#foreach( $p in $output-packets )
# $p.app_protocol://$p.destination_address_name   $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A OUTPUT -p $p.protocol -m $p.protocol -d $p.destination_address --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A INPUT  -p $p.protocol -m $p.protocol -s $p.destination_address --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A OUTPUT -p $p.protocol -d $p.destination_address -j ACCEPT
#end

#end

# Enable ICMP output for all interfaces
-A OUTPUT --protocol icmp --icmp-type echo-reply               -j ACCEPT
-A OUTPUT --protocol icmp --icmp-type destination-unreachable  -j ACCEPT
-A OUTPUT --protocol icmp --icmp-type echo-request             -j ACCEPT
-A OUTPUT --protocol icmp --icmp-type time-exceeded            -j ACCEPT

#if ( $custom-output-rules.size() > 0 )
# Custom OUTPUT Rules
#foreach( $rule in $custom-output-rules )
# $rule.description / $rule.justification
$rule.rule
#end
#end
#
# FORWARD packets 2
#
#if ( $blocked-ip-addresses.size() > 0 )
#
# BLOCKED HOSTS
#
#foreach( $p in $blocked-ip-addresses )
# $p.reason
-A FORWARD -s $p.ip -j $p.type
#end

#end
#foreach( $p in $forward-packets )
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name   $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A FORWARD -s $p.source_address -d $p.destination_address -i $p.input_interface -o $p.output_interface -p $p.protocol -m $p.protocol --dport $p.destination_port -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -s $p.destination_address -d $p.source_address -i $p.output_interface -o $p.input_interface -p $p.protocol -m $p.protocol --sport $p.destination_port -m state --state RELATED,ESTABLISHED -j ACCEPT
#else
-A FORWARD -s $p.source_address -d $p.destination_address -i $p.input_interface -o $p.output_interface -p $p.protocol  -j ACCEPT
#end

#end

#if ( $forward-packets.size() > 0 )
# Enable ICMP forward for all interfaces
-A FORWARD --protocol icmp --icmp-type echo-reply               -j ACCEPT
-A FORWARD --protocol icmp --icmp-type destination-unreachable  -j ACCEPT
-A FORWARD --protocol icmp --icmp-type echo-request             -j ACCEPT
-A FORWARD --protocol icmp --icmp-type time-exceeded            -j ACCEPT
#end
#if ( $custom-forward-rules.size() > 0 )

# Custom FORWARD Rules
#foreach( $rule in $custom-forward-rules )
# $rule.description / $rule.justification
$rule.rule
#end
#end

# for tcp --reject-with tcp-reset
# for REJECT we send tcp packet with ACK and RST flags
-A OUTPUT  -p tcp -m tcp --tcp-flags ACK,RST ACK,RST -j ACCEPT

-A OUTPUT  -j LOG --log-prefix "Drop output packet:"
-A INPUT   -j LOG --log-prefix "Drop input packet:"
-A FORWARD -j LOG --log-prefix "Drop forward packet:"

# send tcp-reset for tcp connections
-A OUTPUT   -p tcp -j REJECT --reject-with tcp-reset
-A INPUT    -p tcp -j REJECT --reject-with tcp-reset
-A FORWARD  -p tcp -j REJECT --reject-with tcp-reset

# drop packets by default for other protocols

COMMIT

# default policy is ACCEPT because nat is virtual and packet pass FORWARD chain always
*nat
:PREROUTING  ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT      ACCEPT [0:0]

#foreach( $p in $forward-packets )
#if ($p.type == "SNAT")
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name    $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A POSTROUTING -s $p.source_address  -d $p.destination_address -p $p.protocol  --dport $p.destination_port -o $p.output_interface -j SNAT --to-source $p.source_nat_address
#else
-A POSTROUTING -s $p.source_address  -d $p.destination_address -p $p.protocol  -o $p.output_interface -j SNAT --to-source $p.source_nat_address
#end

#elseif($p.type == "DNAT")
# $p.source_address_name -> $p.app_protocol://$p.destination_address_name     $p.source_service $p.source_to_dest_service_sign $p.destination_service
#if ($p.destination_port > 0 )
-A PREROUTING -d $p.destination_nat_address -p $p.protocol -m $p.protocol --dport $p.destination_nat_port -j DNAT --to-destination $p.destination_address:$p.destination_port
#else
-A PREROUTING -d $p.destination_nat_address -p $p.protocol -j DNAT --to-destination $p.destination_address
#end

#end
#end
#if ( $custom-prerouting-rules.size() > 0 )
# Custom PREROUTING Rules
#foreach( $rule in $custom-prerouting-rules )
# $rule.description / $rule.justification
$rule.rule
#end
#end
#if ( $custom-postrouting-rules.size() > 0 )

# Custom POSTROUTING Rules
#foreach( $rule in $custom-postrouting-rules )
# $rule.description / $rule.justification
$rule.rule
#end
#end

COMMIT
